import { Canister, query, text, update, Void, Vec, Record, StableBTreeMap, Result, nat64, float64, ic,int8, Principal} from 'azle';
import { v4 as uuidv4 } from "uuid";

const Driver = Record({
  id: text,
  driverPrincipal: Principal,
  name: text,
  phoneNumber: text,
  createdDate: nat64,
});

const Customer = Record({
  id: text,
  customerPrincipal: Principal,
  name: text,
  phoneNumber: text,
  createdDate: nat64,
})
const CustomerPayload = Record({
  name: text,
  phoneNumber: text
})
const DriverPayload = Record({
  name: text,
  phoneNumber: text
})

const Reservation = Record({
  id: text,
  customerId: text,
  pickupLocation: text,
  destination: text,
  status: int8,
  price: float64,
  driverId: text,
  reservationDate: nat64,
});
const ReservationPayload = Record({
  customerId: text,
  pickupLocation: text,
  destination: text,
});

const reservationStatus: { [key: number]: string } = {
  0: "Waiting",
  1: "Accepted",
  2: "On the Way",
  3: "Arrived",
  4: "Cancelled"
}

const customerStorage = StableBTreeMap(text, Customer, 0);
const driverStorage = StableBTreeMap(text, Driver, 1);
const reservationStorage = StableBTreeMap(text, Reservation, 2);


function isValidPhoneNumber(number: text): boolean {
  const regexExp = /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/;
  return regexExp.test(number);
}

// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0
}

 // Helper function to ensure the input id meets the format used for ids generated by uuid
 function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}

function validateCustomerPayload(payload: typeof CustomerPayload): Vec<text>{
  const errors = []
  const {name, phoneNumber} = payload; 
  if(isInvalidString(name)){
    errors.push(`name='${name}' cannot be empty.`)
  }
  if(!isValidPhoneNumber(phoneNumber)){
    errors.push(`Invalid phone number='${phoneNumber}'.`)
  }
  return errors;
}
function validateDriverPayload(payload: typeof DriverPayload): Vec<text>{
  const errors = []
  const {name, phoneNumber} = payload; 
  if(isInvalidString(name)){
    errors.push(`name='${name}' cannot be empty.`)
  }
  if(!isValidPhoneNumber(phoneNumber)){
    errors.push(`Invalid phone number='${phoneNumber}'.`)
  }
  return errors;
}
function validateReservationPayload(payload: typeof ReservationPayload): Vec<text>{
  const errors = []
  const {destination,pickupLocation } = payload; 
  if(isInvalidString(destination)){
    errors.push(`destination='${destination}' cannot be empty.`)
  }
  if(!isValidPhoneNumber(pickupLocation)){
    errors.push(`Invalid pickup location='${pickupLocation}'.`)
  }
  return errors;
}


function driverInStorage(id: text): typeof Driver{
  const driver = driverStorage.values();
  const queryDriver = driver.find(
    (driver: typeof Driver) =>
      driver.id === id
  );
  return queryDriver;
}

function reservationInStorage(id: text){
  const reservation = reservationStorage.values();
  const queryReservation = reservation.find(
    (reservation: typeof Reservation) =>
      reservation.id === id
  );
  return queryReservation;
}

function driverInOrder(id: text){
  const reservation = reservationStorage.values();
  const queryReservation = reservation.find(
    (reservation: typeof Reservation) =>
      (reservation.id === id && (reservation.status === 1 || reservation.status === 2))
  );
  return queryReservation;
}

export default Canister({
  registerCustomer: update([CustomerPayload], Result(text, text), (payload) => {
    let inputValidationErrors = validateCustomerPayload(payload)
    if(inputValidationErrors.length){
      return Result.Err(`Input validations failed. Errors=[${inputValidationErrors}].`)
    }
    const cust = {
      id: uuidv4(),
      customerPrincipal: ic.caller(),
      name: payload.name,
      phoneNumber: payload.phoneNumber,
      createdDate: ic.time()
    }
    customerStorage.insert(cust.id, cust);
    return Result.Ok(cust.id);
  }),

  registerDriver: update([DriverPayload], Result(text, text), (payload) => {
    let inputValidationErrors = validateDriverPayload(payload)
    if(inputValidationErrors.length){
      return Result.Err(`Input validations failed. Errors=[${inputValidationErrors}].`)
    }
    const driver = {
      id: uuidv4(),
      driverPrincipal: ic.caller(),
      name: payload.name,
      phoneNumber: payload.phoneNumber,
      createdDate: ic.time()
    }
    driverStorage.insert(driver.id, driver);
    return Result.Ok(driver.id);
  }),

  createReservation: update([ReservationPayload], Result(text, text), (payload) => {
    const customer = customerStorage
      .values()
      .find((c: typeof Customer) => c.id === payload.customerId);
    if (!customer) {
      return Result.Err("Customer is not registered");
    }
    if(customer.customerPrincipal.toString() !== ic.caller().toString()){
      return Result.Err("Caller is not the customer's principal");
    }
    let inputValidationErrors = validateReservationPayload(payload)
    if(inputValidationErrors.length){
      return Result.Err(`Input validations failed. Errors=[${inputValidationErrors}].`)
    }
    const reservation = {
      id: uuidv4(),
      customerId: payload.customerId,
      pickupLocation: payload.pickupLocation,
      destination: payload.destination,
      status: 0,
      price: 0,
      driverId: "",
      reservationDate: ic.time(),
    };
    reservationStorage.insert(reservation.id, reservation);
    return Result.Ok(`Transaction with ID ${reservation.id} was created successfully`);
  }),

  userGetReservationById: query([text, text], Result(Reservation, text), (customerId, reservationId) => {
    const queryReservation = reservationStorage
      .values()
      .find(
        (reservation: typeof Reservation) =>
          reservation.id === reservationId &&
          reservation.customerId === customerId
      );
    if (!queryReservation) {
      return Result.Err(`Transaction not found!`);
    }
    return Result.Ok(queryReservation);
  }),

  userGetAllReservation: query([text], Result(Vec(Reservation), text), (customerId) => {
    const queryCustomer = customerStorage
      .values()
      .find((customer: typeof Customer) => customer.id === customerId);

    if (!queryCustomer) {
      return Result.Err(`Customer not found!`);
    }
    const queryReservation = reservationStorage
      .values()
      .filter(
        (reservation: typeof Reservation) =>
          reservation.customerId === customerId
      );
    if (!queryReservation) {
      return Result.Err(`Transaction not found!`);
    }
    return Result.Ok(queryReservation);
  }),

  driverGetAllReservation: query([text], Result(Vec(Reservation), text), (driverId) => {
    const queryDriver = driverStorage
      .values()
      .find((driver: typeof Driver) => driver.id === driverId);
    if (!queryDriver) {
      return Result.Err(`Customer not found!`);
    }
    const queryReservation = reservationStorage
      .values()
      .filter(
        (reservation: typeof Reservation) => reservation.customerId === driverId
      );
    if (!queryReservation) {
      return Result.Err(`Transaction not found!`);
    }
    return Result.Ok(queryReservation);
  }),

  driverGetWaitingReservation: query([text], Result(Vec(Reservation), text), (id) => {
    if (!driverInStorage(id)) {
      return Result.Err(`Driver not found!`);
    }
    const queryReservation = reservationStorage
      .values()
      .filter((reservation: typeof Reservation) => reservation.status === 0);
    if (!queryReservation) {
      return Result.Err(`Transaction not found!`);
    }
    return Result.Ok(queryReservation);
  }),

  driverTakeReservation: update([text, text], Result(text, text), (driverId, transactionId) => {
    let driver =driverInStorage(driverId)
    if (!driver){
      return Result.Err(`Driver not found!`);
    }
    if(driver.driverPrincipal.toString() !== ic.caller().toString()){
      return Result.Err("Caller is not the driver's principal");
    }
    const reservation = reservationInStorage(transactionId);
    if (!reservation){
      return Result.Err(`Reservation not found!`);
    }
    if (driverInOrder(driverId)){
      return Result.Err(`Driver Already In Order!`);
    }
    if (reservation.status != 0){
      return Result.Err(`Reservation status is ${reservationStatus[reservation.status]}`);
    }
    reservation.status = 1;
    reservation.driverId = driverId;
    reservationStorage.insert(reservation.id, reservation);
    return Result.Ok(`Reservation with ID ${transactionId} is taken by Driver with ID ${driverId}`);
  }),

  driverOnTheWay: update([text, text], Result(text, text), (driverId, transactionId) => {
    let driver =driverInStorage(driverId)
    if (!driver){
      return Result.Err(`Driver not found!`);
    }
    if(driver.driverPrincipal.toString() !== ic.caller().toString()){
      return Result.Err("Caller is not the driver's principal");
    }
    const reservation = reservationInStorage(transactionId);
    if (!reservation || reservation.driverId != driverId){
      return Result.Err(`Reservation not found!`);
    }
    if (reservation.status != 1){
      return Result.Err(`Reservation status is ${reservationStatus[reservation.status]}`);
    }
    reservation.status = 2;
    reservationStorage.insert(reservation.id, reservation);
    return Result.Ok(`Reservation with ID ${transactionId} is on the way`);
  }),

  driverArrived: update([text, text, float64], Result(text, text), (driverId, transactionId, price) => {
    let driver =driverInStorage(driverId)
    if (!driver){
      return Result.Err(`Driver not found!`);
    }
    if(driver.driverPrincipal.toString() !== ic.caller().toString()){
      return Result.Err("Caller is not the driver's principal");
    }
    const reservation = reservationInStorage(transactionId);
    if (!reservation || reservation.driverId != driverId){
      return Result.Err(`Reservation not found!`);
    }
    if (reservation.status != 2){
      return Result.Err(`Reservation status is ${reservationStatus[reservation.status]}`);
    }
    reservation.status = 3;
    reservation.price = price;
    reservationStorage.insert(reservation.id, reservation);
    return Result.Ok(`Reservation with ID ${transactionId} is on the way`);
  }),

  driverCancel: update([text, text], Result(text, text), (driverId, transactionId) => {
    let driver =driverInStorage(driverId)
    if (!driver){
      return Result.Err(`Driver not found!`);
    }
    if(driver.driverPrincipal.toString() !== ic.caller().toString()){
      return Result.Err("Caller is not the driver's principal");
    }
    const reservation = reservationInStorage(transactionId);
    if (!reservation || reservation.driverId != driverId){
      return Result.Err(`Reservation not found!`);
    }
    if (reservation.status != 0){
      return Result.Err(`Reservation status is ${reservationStatus[reservation.status]}`);
    }
    reservation.status = 4;
    reservationStorage.insert(reservation.id, reservation);
    return Result.Ok(`Reservation with ID ${transactionId} was canceled`);
  })
});

globalThis.crypto = {
  // @ts-ignore
 getRandomValues: () => {
     let array = new Uint8Array(32);

     for (let i = 0; i < array.length; i++) {
         array[i] = Math.floor(Math.random() * 256);
     }

     return array;
 }
};